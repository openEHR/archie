/* Automatically generated by GNU msgfmt.  Do not modify!  */
public class openehrArchie_nl extends java.util.ResourceBundle {
  private static final java.lang.String[] table;
  static {
    java.lang.String[] t = new java.lang.String[574];
    t[0] = "";
    t[1] = "Project-Id-Version: \nReport-Msgid-Bugs-To: \nPO-Revision-Date: \nLast-Translator: Pieter Bos <pieter.bos@nedap.com>\nLanguage-Team: \nLanguage: nl\nMIME-Version: 1.0\nContent-Type: text/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\nX-Generator: Poedit 2.4.2\n";
    t[4] = "The value {0} must be {1}";
    t[5] = "De waarde {0} moet {1} zijn";
    t[6] = "code in terminology not used in archetype definition";
    t[7] = "code uit terminologie is niet gebruikt in de definitie van het archetype";
    t[8] = "Term binding key {0} points to a path that cannot be found in the archetype";
    t[9] = "Het pad {0} uit een term binding kan niet worden gevonden in het archetype";
    t[14] = "Could not find parent object for {0} but it should have been prechecked. Could you report this as a bug?";
    t[15] = "Kan parent object voor {0} niet vinden. Deze melding is waarschijnlijk een bug, zou u dat kunnen melden?";
    t[22] = "value code validity. Each value code (at-code) used in a term constraint in the archetype definition must be defined in the term_definitions part of the terminology of the flattened form of the current archetype.";
    t[23] = "Geldigheid van een value code. Elke value code (at-code) gebruikt in een term constraint in de definitie van het archetype moet in de term definities van de flat form van dit archetype opgenomen zijn.";
    t[24] = "Multiple values for Primitive Object constraint {0}: {1}";
    t[25] = "Meerdere waarden voor Primitive Object constraint {0}: {1}";
    t[28] = "Template overlay {0} had validation errors";
    t[29] = "Template overlay {0} heeft validatiefouten";
    t[30] = "Parent archetype {0} not found or can not be flattened";
    t[31] = "Parent archetype {0} niet gevonden, of het bevat een fout waardoor het niet kan worden geflattened";
    t[32] = "The existence {0} of attribute {2}.{3} does not match existence {1} of the reference model";
    t[33] = "De existence {0} van attribuut {2}.{3} klopt niet bij existence {1} van het referentiemodel";
    t[34] = "Assumed value {0} from the C_TERMINOLOGY_CODE is not part of value set {1}. Expected one of {2}";
    t[35] = "De assumed value {0} van de C_TERMINOLOGY_CODE is geen onderdeel van value set/codelijst {1}. Verwacht was een van de codes {2}";
    t[46] = "Merged schema {0} into schema {1}";
    t[47] = "Schema {0} samengevoegd in schema {1}";
    t[48] = "Syntax error: existence must be one of 0..0, 0..1, or 1..1";
    t[49] = "Syntaxfout: existence moet een van 0..0, 0..1 of 1..1 zijn";
    t[50] = "The use_archetype with type {0} does not match the archetype slow (allow_archetype) with type {1}";
    t[51] = "Use_archetype met {0} klopt niet met het archetype slot met type {1} uit het gespecialiseerde archetype";
    t[54] = "A {0} cannot specialize a {1}";
    t[55] = "Een {0} kan niet een {1} specialiseren";
    t[58] = "RM Release version {0} is an invalid format for a version, should be x.x.x-(rc|alpha(x)?)?";
    t[59] = "Het formaat van de RM release version {0} klopt niet. dit moet in het formaat  x.x.x-(rc|alpha(x)?)? zijn";
    t[62] = "value set code {0} is not present in terminology";
    t[63] = "de code {0} van een value set bestaat niet in de terminologie";
    t[66] = "Tuple member attribute {0} is not an attribute of type {1}";
    t[67] = "Onderdeel van tupel {0} is geen attribuut van type {1}";
    t[68] = "Attribute cardinality {0} does not conform to parent cardinality {1}";
    t[69] = "De cardinaliteit {0} van dit attribuut komt niet overeen met de cardinaliteit van het attribuut dat gespecializeerd wordt: {1}";
    t[72] = "Attribute tuple with members {0} does not conform to parent attribute tuple";
    t[73] = "Atribuut-tupel met members {0} komt niet overeen met attribuut-tupel dat gespecializeerd wordt";
    t[74] = "Multiple values for Tuple constraint {0}: {1}";
    t[75] = "Meerdere waarden voor Tuple constraint {0}: {1}";
    t[80] = "The validation of a template overlay failed";
    t[81] = "De validate van een template overlay is niet geslaagd";
    t[82] = "Use_node (C_COMPLEX_OBJECT_PROXY) points to a path that resolves to more than one object";
    t[83] = "Use_node, hergebruik van een deel van het archetype, verwijst naar een pad dat verwijst naar meer dan \u00e9\u00e9n object";
    t[84] = "value-set members defined. The member codes of a value set must be defined in the term definitions of the terminology of the flattened form of the current archetype";
    t[85] = "value-set waardes gedefinieerd. De waardes uit een value-set moeten in de terminology opgenomen zijn van de flat form van dit archetype.";
    t[94] = "an error occurred that has no standard codes";
    t[95] = "er is een fout opgetreden zonder standaard-code";
    t[100] = "Code {0} from C_TERMINOLOGY_CODE constraint is not defined in the terminology";
    t[101] = "Code {0} van deze C_TERMINOLOGY_CODE bestaat niet in de terminologie";
    t[106] = "{0} is not a known attribute of {1}";
    t[107] = "{0} is niet een bekend attribuut van {1}";
    t[108] = "Use_archetype {0} does not match the expression of the archetype slot it specialized in the parent";
    t[109] = "Use_archetype {0} komt niet overeen met de restricties van het archetype slot dat het specialiseert";
    t[110] = "The value {0} must be one of:";
    t[111] = "De waarde {0} moet aan een van de volgende voorwaarden voldoen:";
    t[112] = "Attribute existence is {0}, which does not conform to parent existince {1}";
    t[113] = "De existence {0} van dit attribuut komt niet overeen met die de existence van het attribuut dat gespecializeerd wordt: {1}";
    t[114] = "BMM Schema load error";
    t[115] = "Fout bij het laden van een BMM schema";
    t[118] = "Object does not match tuple: {0}";
    t[119] = "Object komt niet overeen met tupel: {0}";
    t[122] = "A differential path was used in an attribute, but this is not allowed in an archetype that has no parent";
    t[123] = "In dit attribuut is een differential path gebruikt, maar dat is niet toegestaan in een niet specialiserend archetype";
    t[126] = "Object should be type {0}, but was {1}";
    t[127] = "Object moet van type {0} zijn, maar is van type {1}";
    t[128] = "The occurrences upper limit of the C_OBJECT {0} was {1}, which is greater than the parent attribute cardinality {2}";
    t[129] = "De bovenste limiet van de occurrences van dit C_OBJECT {0} was {1}. Dat is groter dan de cardinaliteit van het attribuut dat deze C_OBJECT bevat, {2}";
    t[138] = "Node id numbers should be unique without their ac, at or id-prefix, to ensure the possibility of conversion to ADL 1.4";
    t[139] = "Node id nummers moeten uniek zijn zonder hun ac, at of id-prefix, om conversie naar ADL 1.4 mogelijk te maken";
    t[140] = "value-set id defined. The identifying code of a value set must be defined in the term definitions of the terminology of the current archetype";
    t[141] = "value-set id gedefinieerd. De identificerende code van een value set moet in de termdefinities van de terminologie van dit archetype opgenomen zijn.";
    t[142] = "The cardinality of Attribute {0}.{1} is the same as in the reference model - this is not allowed due to strict multiplicities validation being enabled";
    t[143] = "De cardinaliteit van attribuut {0}.{1} is hetzelfde als in het referentiemodel. Dit is niet toegestaan als strikte validatie is ingeschakeld";
    t[144] = "A closed archetype slot cannot have its includes or excludes assertions modified";
    t[145] = "Een gesloten archetype slot kan geen wijzigingen meer bevatten aan de includes en excludes-onderdelen";
    t[150] = "{0} and {1}";
    t[151] = "{0} en {1}";
    t[158] = "Error in parent archetype. Fix those errors before continuing with this archetype: {0}";
    t[159] = "Fout in het gespecialiseerde archetype. Los deze fout in het bovenliggende archetype eerst op, alvorens verder te gaan met dit archetype. De gevonden fouten: {0}";
    t[162] = "C_OBJECT in this archetype with class {0} is prohibited, which means its class must be the same as parent type {1}";
    t[163] = "Het C_OBJECT in dit archetype met klasse {0} heeft 0 als maximum occurrences (prohibited), maar heeft niet dezelfde klasse als het C_OBJECT dat gespecializeerd wordt: {1}";
    t[166] = "Duplicate instance of Reference Model model {0} found; original schema {1}; ignoring instance from schema {2}";
    t[167] = "Dubbele instantie van reference model {0} gevonden. Het originele schema is {1}. Het schema van instantie {2} wordt genegeerd";
    t[180] = "An object with the new node id {0} cannot be prohibited";
    t[181] = "Een object met een nieuw node id {0} mag geen occurrences van maximaal 0 hebben";
    t[182] = "Attribute {0}.{1} cannot be constrained by a {2}";
    t[183] = "Attribuut {0}.{1} kan niet worden beperkt met een {2}";
    t[186] = "Original language not defined in terminology";
    t[187] = "Originele taal bestaat niet in de terminologie";
    t[190] = "Use_node (C_COMPLEX_OBJECT_PROXY) points to type {0}, which does not conform to type {1}";
    t[191] = "Use_node, hergebruik van een deel van het archetype, verwijst naar type {0}, maar dat klopt niet met type {1} zoals gevonden uit het pad";
    t[202] = "greater than {0}";
    t[203] = "groter dan {0}";
    t[210] = "Use_archetype specializes an archetype root pointing to {0}, but the archetype {1} is not a descendant";
    t[211] = "Use_archetype {1} specialiseert een andere use_archetype die verwijst naar {0}. Maar het archeytpe {1} specialiseert niet {0}";
    t[216] = "Use_archetype points to type {0}, which is not conformant for type {1} of the archetype root used";
    t[217] = "Use_archetype verwijst naar een pad met type {0}. Dit komt niet overeen met type {1} zoals opgegeven in use_archetype";
    t[222] = "Use_archetype references archetype id {0}, but no archetype was found";
    t[223] = "Use_archetype verwijst naar archetype met id {0}, maar dit archetype kon niet gevonden worden";
    t[228] = "Language {0} is defined in the translations, but is not present in the terminology";
    t[229] = "Taal {0} is opgenomen bij de vertalingen, maar ontbreekt in de terminologie";
    t[236] = "The specialisation depth of the archetypes must be one greater than the specialisation depth of the parent archetype";
    t[237] = "De specialisation depth van het archetype moet \u00e9\u00e9n groter zijn dan die van het gespecialiseerde archetype";
    t[242] = "Attribute {0}.{1} cannot contain type {2}";
    t[243] = "Attribuut {0}.{1} mag geen type {2}  bevatten";
    t[250] = "Node id {0} is not valid here because it redefines an object illegally";
    t[251] = "Node id {0} is hiet niet geldig omdat het een object herdefinieert waar dat niet is toegestaan";
    t[256] = "The path {0} referenced in the annotations does not exist in the flat archetype or reference model";
    t[257] = "Het pad {0} gebruikt in de annotations bestaat niet in het flattened archetype of referentiemodel";
    t[262] = "Original language {0} is not defined in the terminology";
    t[263] = "Originele taal {0} ontbreekt in de terminologie";
    t[268] = "Archetype terminology not defined";
    t[269] = "Archetype terminology ontbreekt";
    t[270] = "The attribute contains {0} objects that are required, but only has an upper cardinality of {1}";
    t[271] = "Het attribuut bevat {0} waarden die verplicht zijn, maar heeft een maximale cardinaliteit van {1}";
    t[282] = "empty";
    t[283] = "leeg";
    t[284] = "Code {0} is in the terminology, but not used in the archetype";
    t[285] = "Code {0} uit de terminologie is niet gebruikt in de definitie van het archetype";
    t[294] = "The code specialization depth of code {0} is {1}, which is greater than archetype specialization depth {2}";
    t[295] = "De specialization depth of code {0} is {1}, maar mag niet groter zijn dan {2}, de specialization depth van het archetype";
    t[300] = "The validation of the parent archetype failed";
    t[301] = "Het bovenliggende archetype bevat een fout, en valideert daardoor niet. Daardoor kan dit archetype niet gevalideerd worden.";
    t[302] = "No Reference Model schema found for package ''{0}''";
    t[303] = "Geen referentiemodel-schema gevonden voor package \u201c{0}\u201d";
    t[304] = "The existence of attribute {0}.{1} is the same as in the reference model - this is not allowed due to strict existence validation being enabled";
    t[305] = "De existence van attribuut {0}.{1} is hetzelfde als in het referentiemodel. Dit is niet toegestaan als strikte validatie ingeschakeld is";
    t[308] = "Schema {0} archetype parent class {1} not defined in schema";
    t[309] = "Schema {0} archetype parent class {1} niet gedefinieerd in schema";
    t[312] = "equal to {0}";
    t[313] = "gelijk aan {0}";
    t[316] = "A specialized archetype slot must have the same id as the parent id {0}, but it was {1}";
    t[317] = "Een specialiserend archetype slot moet dezelfde id hebben als in het gespecialiseerde archetype {0}, maar het was {1}";
    t[320] = "Term binding key {0} is not present in the terminology";
    t[321] = "De code {0} van een term binding bestaat niet in de terminologie";
    t[326] = "Use_node (C_COMPLEX_OBJECT_PROXY) points to a path that cannot be found: {0}";
    t[327] = "Use_node, hergebruik van een deel van het archetype, verwijst naar een pad dat niet kan worden gevonden: {0}";
    t[328] = "Reference Model BMM schema {0} incompatible with current release {1} of the tool; obtain up to date schemas";
    t[329] = "Bmm Schema {0} kan niet worden geladen met versie {1} van deze software";
    t[332] = "anything";
    t[333] = "willekeurig";
    t[336] = "The occurrences of all C_OBJECTS under this attributes is at least {0}, which does not fit in the upper limit of the cardinality of the attribute, {1}";
    t[337] = "De occurrences van alle C_OBJECTS onder dit attribuut is ten minste {0}. Dat past niet in de maximale cardinaliteit van het attibruut {1}";
    t[340] = "Syntax error: terminology not specified";
    t[341] = "Syntaxfout: terminologie ontbreekt";
    t[342] = "Archetype referenced in use_archetype points to class {0}, which does not exist in this reference model";
    t[343] = "Het archetype waarnaar use_archetype verwijst, verwijst naar klasse {0}. Deze klasse bestaat niet in het referentiemodel";
    t[352] = "the given id code is not valid";
    t[353] = "de gegeven id code is niet geldig";
    t[354] = "Id code {0} in terminology is not a valid term code, should be id, ac or at, followed by digits";
    t[355] = "Id code {0} in de terminology is geen geldige term-code. De code zou moeten beginnen met id, ac of at, gevolgd door getallen";
    t[356] = "Archetype root must have an archetype reference or be prohibited (occurrences matches 0)";
    t[357] = "Use_archetype moet verwijzen naar een archetype, of beperkt zijn tot occurrences 0";
    t[358] = "Sibling order {0} refers to missing node id";
    t[359] = "Sibling order {0} verwijst naar een ontbrekende node id";
    t[360] = "Documentation";
    t[361] = "Documentatie";
    t[362] = "at least {0}";
    t[363] = "minimaal {0}";
    t[370] = "Code {0} from the C_TERMINOLOGY_CODE constraint has specialization depth {1}, but this must be no greater than {2}";
    t[371] = "Code {0} van de C_TERMINOLOGY_CODE heeft specialization depth {1}, maar dit mag niet groter dan {2} zijn voor dit archetype";
    t[372] = "Error";
    t[373] = "Fout";
    t[380] = "C_OBJECT with RM type {0} must have a node id";
    t[381] = "C_OBJECT met RM type {0} moet een node id hebben, maar heeft dat niet";
    t[382] = "at most {0}";
    t[383] = "maximaal {0}";
    t[384] = "The node_id of the root object of the archetype must be of the form id1'{.1}'*, where the number of .1 components equals the specalisation depth, and must be defined in the terminology";
    t[385] = "De node id van het bovenste object van het archetype moet van de form id'{.1}'* zijn, waar het aantal van .1 onderdelen gelijk is aan de specialization depth, and de code moet bestaan in de terminologie";
    t[386] = "Syntax error: existence must be one of 0..0, 0..1, or 1..1, but was {0}";
    t[387] = "Syntaxfout: existence moet een van 0..0, 0..1 of 1..1 zijn, maar was {0}";
    t[394] = "Message at {0} ({1}):  {2}";
    t[395] = "Bericht bij {0} ({1}): {2}";
    t[396] = "RM type in id {0} does not match RM type in definition {1}";
    t[397] = "Reference model type {0} correspondeert niet met het reference model type {1} in de definitie van het archetype";
    t[404] = "Original language is missing in archetype";
    t[405] = "Archetype heeft geen originele taal";
    t[408] = "Attribute {0} of class {1} does not match existence {2}";
    t[409] = "Attribuut {0} van class {1} komt niet overeen met existence {2}";
    t[410] = "at path: ";
    t[411] = "op het pad: ";
    t[414] = "The node id is not in the form id1.1....1: {0}";
    t[415] = "De node id is niet in de form id1(.1)*: {0}";
    t[416] = "Translation details language {0} has an incorrect key: {1}";
    t[417] = "De beschrijving van de vertaling {0} zou een gelijke sleutelwaarde als de taal moeten hebben, maar heeft de waarde {1}";
    t[418] = "Attribute {0} is a non-tuple attribute in the parent archetype, but a tuple attribute in the current archetype. That is not allowed";
    t[419] = "Attribuut {0} is geen tuple in het archetype dat gespecializeerd wordt, maar wel een tuple attribuut in het huidige archetype. Dat is niet toegestaan";
    t[424] = "Archetype with id {0} used in use_archetype, but it was not found";
    t[425] = "Archetype met id {0} is gebruikt met use_archetype, maar het archetype kon niet worden gevonden";
    t[430] = "The attribute {0} of type {1} can only have a single value, but the occurrences of the C_OBJECTS below has an upper limit of more than 1";
    t[431] = "Het attribuut {0} van type {1} kan maar \u00e9\u00e9n waarde hebben, maar de occurrences van de C_OBJECTS in dit attibuut heeft een maximale limiet van meer dan 1";
    t[432] = "Duplicate attribute constraint with name {0}";
    t[433] = "Attribuut met naam {0} is twee keer gedefinieerd - dit mag maar \u00e9\u00e9n keer zijn";
    t[436] = "Single valued attributes can not have a cardinality";
    t[437] = "Attributen die maar \u00e9\u00e9n waarde kunnen bevatten mogen geen cardinaliteit hebben";
    t[440] = "Node id {0} already used in path {1}";
    t[441] = "Node id {0} is al gebruikt in pad {1}";
    t[442] = "Id code {0} in terminology is of a different specialization depth than the archetype";
    t[443] = "Id code {0} uit de terminologie heeft een andere specialization depth dan het archetype";
    t[444] = "The cardinality {0} of attribute {2}.{3} does not match cardinality {1} of the reference model";
    t[445] = "De cardinaliteit {0} van attribuut {2}.{3} klopt niet met de cardinaliteit {1} uit het referentiemodel";
    t[452] = "node id must be defined in flat terminology";
    t[453] = "node id ontbreekt in de flat terminologie";
    t[454] = "The specialisation depth of the archetype, {0}, must be one greater than the specialisation depth of the parent archetype, {1}";
    t[455] = "De specialisation depth van het archetype, {0}, moet \u00e9\u00e9n groter zijn dan die van het gespecialiseerde archetype, {1}";
    t[456] = "Node id {0} is used in the archetype, but missing in the terminology";
    t[457] = "Node id {0} is gebruikt in het archetype, maar ontbreekt in de terminologie";
    t[462] = "Archetype terminology contains no term definitions";
    t[463] = "De terminologie van dit archetype bevat geen termdefinities";
    t[464] = "Node id {0} is not valid here";
    t[465] = "Node id {0} is hier niet geldig";
    t[466] = "Warning";
    t[467] = "Waarschuwing";
    t[468] = "Term binding key {0} in path format is not present in archetype";
    t[469] = "Het pad {0} uit een term binding kan niet worden gevonden in het archetype";
    t[470] = "Use_node (C_COMPLEX_OBJECT_PROXY) must point to a C_COMPLEX_OBJECT, but points to a {0}";
    t[471] = "Use_node, hergebruik van een deel van het archetype, moet naar een C_COMPLEX_OBJECT verwijzen, maar verwijst naar een {0}";
    t[476] = "Code {0} from the C_TERMINOLOGY_CODE constraint is not defined in the terminology";
    t[477] = "Code {0} van deze C_TERMINOLOGY_CODE bestaat niet in de terminology";
    t[486] = "Term binding key {0} is not present in terminology";
    t[487] = "De code {0} van een term binding bestaat niet in de terminologie";
    t[490] = "Type name {0} does not exist";
    t[491] = "Type met naam {0} bestaat niet";
    t[496] = "ADL version {0} is an invalid format for a version, should be x.x.x-(rc|alpha(x)?)?";
    t[497] = "ADL-versie {0} is in een incorrect formaat. Dit zou een versie in het formaat x.x.x-(rc|alpha(x)?)? moeten zijn";
    t[498] = "Object with node id {0} should be specialized before excluding the parent node";
    t[499] = "Object met node id {0} moet gespecialiseerd worden voordat de parent node excluded wordt";
    t[506] = "an tuple member cannot specialize an attribute that is a non-tuple attribute in its parent";
    t[507] = "een onderdeel van een tupel kan geen attribuut specialiseren die geen tupel is";
    t[518] = "less than {0}";
    t[519] = "kleiner dan {0}";
    t[520] = "value-set members unique. The member codes of a value set must be unique within the value set";
    t[521] = "value-set waardes uniek. Elke waarde mag maar \u00e9\u00e9n keer gebruikt worden in een value-set";
    t[522] = "Archetype root must reference an existing archetype";
    t[523] = "Use_archetype moet verwijzen naar een bestaand archetype";
    t[524] = "Differential path must point to a C_ATTRIBUTE in the flat parent, but it pointed instead to a {0}";
    t[525] = "Het differential pad moet naar een C_ATTRIBUTE verwijzen in het archetype dat gespecialiseerd wordt, maar in plaats daarvan verwijst het naar een {0}";
    t[534] = "Incorrect root node id {0}: it must match the specialization depth of the archetype, which is {1}";
    t[535] = "Fout in root node id {0}: Dit moet kloppen met de specialization depth van het archetype, {1}";
    t[536] = "Cannot redefine a closed archetype slot";
    t[537] = "Een gesloten archetype slot kan niet worden hergedefinieerd";
    t[548] = "Node ID {0} specialization depth does not conform to the archetype specialization depth {1}";
    t[549] = "De specialization depth van node id {0} klopt niet bij de specialization depth {1} van het archetype";
    t[558] = "Differential path {0} was not found in the parent archetype";
    t[559] = "Differential path {0} is niet gevonden in het archetype dat gespecialiseerd wordt";
    t[560] = "Attribute has {0} occurrences, but must be {1}";
    t[561] = "Attribuut komt {0} keer voor, maar dit moet {1} zijn";
    t[562] = "In the attribute tuple {0} members were specified, but the primitive tuple has {1} members instead";
    t[563] = "In het attribuut tupel zijn {0} members opgenomen, maar het primitive tuple heeft {1} members. Dit moet gelijk zijn";
    t[564] = "Duplicate Reference Model schema found for model ''{0}'' in file {1}, ignoring latter";
    t[565] = "Meer dan \u00e9\u00e9n Reference Model schema gevonden voor model ''{0}'' in bestand {1}. De tweede en volgende worden genegeerd";
    t[566] = "Attribute does not match cardinality {0}";
    t[567] = "Attribuut moet {0} waarden bevatten";
    t[570] = "C_OBJECT in this archetype with node id {0} is prohibited, which means its node id must be the same as parent {1}";
    t[571] = "Het C_OBJECT in dit archetype met node id {0} heeft 0 als maximum occurrences  (prohibited), maar het node id is anders dan die van het C_OBJECT dat gespecialiseerd wordt {1}";
    table = t;
  }
  public java.lang.Object handleGetObject (java.lang.String msgid) throws java.util.MissingResourceException {
    int hash_val = msgid.hashCode() & 0x7fffffff;
    int idx = (hash_val % 287) << 1;
    {
      java.lang.Object found = table[idx];
      if (found == null)
        return null;
      if (msgid.equals(found))
        return table[idx + 1];
    }
    int incr = ((hash_val % 285) + 1) << 1;
    for (;;) {
      idx += incr;
      if (idx >= 574)
        idx -= 574;
      java.lang.Object found = table[idx];
      if (found == null)
        return null;
      if (msgid.equals(found))
        return table[idx + 1];
    }
  }
  public java.util.Enumeration getKeys () {
    return
      new java.util.Enumeration() {
        private int idx = 0;
        { while (idx < 574 && table[idx] == null) idx += 2; }
        public boolean hasMoreElements () {
          return (idx < 574);
        }
        public java.lang.Object nextElement () {
          java.lang.Object key = table[idx];
          do idx += 2; while (idx < 574 && table[idx] == null);
          return key;
        }
      };
  }
  public java.util.ResourceBundle getParent () {
    return parent;
  }
}
